

[info] Starting scala interpreter...
[info] 
import scalaz._
import Scalaz._
import atto._
import Atto._
Welcome to Scala version 2.10.2 (Java HotSpot(TM) 64-Bit Server VM, Java 1.7.0_13).
Type in expressions to have them evaluated.
Type :help for more information.

// So, imported scalaz and atto.
// Atto is organized just like scalaz, so you can import the whole thing or just the parts you want.

scala> letter
res0: atto.Parser[Char] = letter

scala> letter.parse("x")
res1: atto.ParseResult[Char] = Done(,x)

scala> letter.parse("xyz")
res2: atto.ParseResult[Char] = Done(yz,x)

scala> letter.parse("1")
res3: atto.ParseResult[Char] = Fail(1,List(),Failure reading:letter)

scala> letter.parse("")
res4: atto.ParseResult[Char] = Partial(<function1>)

scala> letter.parse("").feed("abc")
res6: atto.ParseResult[Char] = Done(bc,a)

// Simple combinator

scala> many(letter).parse("abc")
res7: atto.ParseResult[List[Char]] = Partial(<function1>)

scala> many(letter).parse("abc").feed("def")
res8: atto.ParseResult[List[Char]] = Partial(<function1>)

scala> many(letter).parse("abc").feed("def").done
res9: atto.ParseResult[List[Char]] = Done(,List(a, b, c, d, e, f))

// Functor ("normal" .. covariant) 

scala> many(letter).map(_.mkString).parse("abc").feed("def").done
res43: atto.ParseResult[String] = Done(,abcdef)

// Another combinator

scala> letter ~ digit
res16: atto.Parser[(Char, Char)] = (letter) ~ digit

scala> (letter ~ digit).parse("a1")
res17: atto.ParseResult[(Char, Char)] = Done(,(a,1))

scala> (many(letter) ~ many(digit)).parse("aaa")
res18: atto.ParseResult[(List[Char], List[Char])] = Partial(<function1>)

scala> (many(letter) ~ many(digit)).parse("aaa").feed("bcd123").done
res19: atto.ParseResult[(List[Char], List[Char])] = Done(,(List(a, a, a, b, c, d),List(1, 2, 3)))

scala> (many(letter) ~ many(digit)).map(p => p._1 ++ p._2).parse("aaa").feed("bcd123").done
res21: atto.ParseResult[List[Char]] = Done(,List(a, a, a, b, c, d, 1, 2, 3))

// kind of a paint having to destructure the halves of the pair, and it gets worse with more stuff
// connneced with twiddles

scala> (letter ~ int ~ digit ~ byte)
res46: atto.Parser[(((Char, Int), Char), Byte)] = (((letter) ~ int) ~ digit) ~ byte

// so you kind of get a left-associative cons list of types built up with pairs. so when you see
// this kind of problem you should think...

// Applicative functor

scala> (many(letter) |@| many(digit))(_ ++ _).parse("aaa").feed("bcd123").done
res22: atto.ParseResult[List[Char]] = Done(,List(a, a, a, b, c, d, 1, 2, 3))

// Monad 

scala> val p = for { n <- int; c <- take(n) } yield c
p: atto.Parser[String] = (int) flatMap ...

scala> p.parse("3abcdef")
res27: atto.ParseResult[String] = Done(def,abc)

scala> p.parse("4abcdef")
res28: atto.ParseResult[String] = Done(ef,abcd)

// NTriples

scala> import NTriples._
import NTriples._

scala> println(test)
#
# Copyright World Wide Web Consortium, (Massachusetts Institute of
# Technology, Institut National de Recherche en Informatique et en
...

// Look at source
// Look at spec
// Note how BNF productions map nicely to parser definitions

scala> triples.parse(test).done
res33: atto.ParseResult[List[atto.NTriples.Triple]] = 
Done(,List(Triple(UriRef(http://example.org/resource1),UriRef(http://example.org/property),UriRef(http://example.org/resource2)), Triple(NodeID(anon),UriRef(http://example.org/property),UriRef(http://example.org/resource2)), Triple(UriRef(http://example.org/resource2),UriRef(http://example.org/property),NodeID(anon)), Triple(UriRef(http://example.org/resource3),UriRef(http://example.org/property),UriRef(http://example.org/resource2)), Triple(UriRef(http://example.org/resource4),UriRef(http://example.org/property),UriRef(http://example.org/resource2)), Triple(UriRef(http://example.org/resource5),UriRef(http://example.org/property),UriRef(http://example.org/resource2)), Triple(UriRef(http://example.org/resource6),UriRef(http://example...

scala> triples.parse(test).done.option.map(_.foreach(println))
Triple(UriRef(http://example.org/resource1),UriRef(http://example.org/property),UriRef(http://example.org/resource2))
Triple(NodeID(anon),UriRef(http://example.org/property),UriRef(http://example.org/resource2))
Triple(UriRef(http://example.org/resource2),UriRef(http://example.org/property),NodeID(anon))
...

// incrementally

scala> val lines = test.lines.map(_ + "\n").toList
lines: List[String] = 
List("#
", "# Copyright World Wide Web Consortium, (Massachusetts Institute of
", "# Technology, Institut National de Recherche en Informatique et en
", "# Automatique, Keio University).
", "#
", "# All Rights Reserved.
", "#

scala> ((triples parse "") /: lines)(_ feed _).done.option.map(_.length)
res48: Option[Int] = Some(28)



